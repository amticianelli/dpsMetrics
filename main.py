# -*- coding: utf-8 -*-
"""IoTHubCountDevices.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rNLg9l8G1aXKLWnkfgrD3Y1MccFAnaVS
"""

from base64 import b64encode, b64decode
from hashlib import sha256
from time import time
from urllib import parse
from hmac import HMAC
import duckdb
import pandas as pd
import yaml
import asyncio
import httpx
from httpx import ConnectTimeout
import time as t
import sys
import datetime


sys.stdin.reconfigure(encoding='utf-8')
sys.stdout.reconfigure(encoding='utf-8')

# Load data from YAML file
with open('data.yaml', 'r') as file:
    data = yaml.safe_load(file)

# DPS Data
dpS = data['dpS']

# IoTHub Data
hubs = data['hubs']



# Generating Token
def generate_sas_token(uri, key, policy_name, expiry=3600):
    ttl = time() + expiry
    sign_key = "%s\n%d" % ((parse.quote_plus(uri)), int(ttl))
    #print(sign_key)
    signature = b64encode(HMAC(b64decode(key), sign_key.encode('utf-8'), sha256).digest())

    rawtoken = {
        'sr' :  uri,
        'sig': signature,
        'se' : str(int(ttl)),
        'skn' : policy_name
    }

    return 'SharedAccessSignature ' + parse.urlencode(rawtoken)

async def deleteRegistration(dpsname, key, policy_name, registrationId):
  defaultUri = f'{dpsname}.azure-devices-provisioning.net'
  
  dpsurl: str = f'https://{dpsname}.services.azure-devices-provisioning.net/registrations/{registrationId}?api-version=2021-10-01'

  saskey: str = generate_sas_token(defaultUri, key, policy_name)

  header: dict = {
    'Content-type': 'application/json',
    'Content-Encoding': 'utf-8',
    'Authorization': f'{saskey}',
  }

  
  async with httpx.AsyncClient() as client:
    result = await client.delete(
      url=dpsurl,
      headers=header,
      timeout=None
    )

    result.raise_for_status()

    print(f'Registration {registrationId} deleted')


async def getDPSData(dpsname, key, policy_name, con_test=False):
    defaultUri = f'{dpsname}.azure-devices-provisioning.net'
    allRegistrations: list[dict] = []
    dpsGroups = await getDPSGroups(dpsname, defaultUri, key, policy_name)

    for group in dpsGroups:
      dpsurl: str = f'https://{dpsname}.services.azure-devices-provisioning.net/registrations/{group}/query?api-version=2021-06-01'

      saskey: str = generate_sas_token(defaultUri, key, policy_name)

      header: dict = {
        'Content-type': 'application/json',
        'Content-Encoding': 'utf-8',
        'Authorization': f'{saskey}',
        'x-ms-max-item-count': '1000'
      }

      payload: dict = {
        "query": "SELECT registrationId,assignedHub,status FROM deviceregistration"
      }

      while True:
        try:
          async with httpx.AsyncClient() as client:
            result = await client.post(
              url=dpsurl,
              json=payload,
              headers=header,
              timeout=None
            )
        except BaseException as e:
          if isinstance(e, ConnectTimeout):
            print(f'Connection to {dpsname} and group {group} timed out')
            t.sleep(10)
            continue
          else:
            print(f'Connection to {dpsname} and group {group} failed')
            t.sleep(10)
            continue

        if result.status_code == 401:
          saskey: str = generate_sas_token(defaultUri, key, policy_name)
          header['Authorization'] = f'{saskey}'
          continue

        result.raise_for_status()

        resultDict = result.json()

        if con_test:
          print(f'Conn to {dpsname} and group {group} OK')
          break

        for idx, registration in enumerate(resultDict):
          del resultDict[idx]['createdDateTimeUtc']
          del resultDict[idx]['substatus']
          #del resultDict[idx]['lastUpdatedDateTimeUtc']
          del resultDict[idx]['etag']
          resultDict[idx]['dpsname'] = dpsname
          resultDict[idx]['group'] = group
          resultDict[idx]['assignedHub'] = resultDict[idx]['assignedHub'].split('.')[0]

        allRegistrations = allRegistrations + resultDict

        continuation_token = result.headers.get("x-ms-continuation")
        if not continuation_token:
          break
        # Add the continuation token to the headers for the next request
        header["x-ms-continuation"] = continuation_token

    print(f'Registrations for {dpsname} : {len(allRegistrations)}') if con_test == False else None
    return allRegistrations

async def getHubData(hubname, key, policy_name, con_test=False):
  defaultUri = f'{hubname}.azure-devices-provisioning.net'
  allDevices = []

  huburlReq: str = f'https://{hubname}.azure-devices.net/devices/query?api-version=2020-09-30'

  saskey: str = generate_sas_token(defaultUri, key, policy_name)

  header: dict = {
    'Content-type': 'application/json',
    'Content-Encoding': 'utf-8',
    'Authorization': f'{saskey}',
    'x-ms-max-item-count': '1000'
  }

  while True:
    async with httpx.AsyncClient() as client:
      result = await client.post(
        url=huburlReq,
        json={'query': 'SELECT deviceId FROM devices'},
        headers=header,
        timeout=None
      )

    if result.status_code == 401:
      saskey: str = generate_sas_token(defaultUri, key, policy_name)
      header['Authorization'] = f'{saskey}'
      continue

    result.raise_for_status()

    # Check if there are more items
    resultDict = result.json()

    for idx, device in enumerate(resultDict):
      resultDict[idx]['iothub'] = hubname

    allDevices = allDevices + resultDict

    if con_test:
      print(f'Conn to {hubname} OK')
      break

    continuation_token = result.headers.get("x-ms-continuation")
    if not continuation_token:
      break
    # Add the continuation token to the headers for the next request
    header["x-ms-continuation"] = continuation_token

  print(f'Devices for {hubname} : {len(allDevices)}') if con_test == False else None

  return allDevices

async def getDPSGroups(dpsname, uri, key, policy_name):
  dpsGroupReq: str = f'https://{dpsname}.azure-devices-provisioning.net/enrollmentGroups/query?api-version=2021-06-01'

  saskey: str = generate_sas_token(uri, key, policy_name)

  header: dict = {
    'Content-type': 'application/json',
    'Content-Encoding': 'utf-8',
    'Authorization': f'{saskey}',
    'x-ms-max-item-count': '1000'
  }

  async with httpx.AsyncClient() as client:
    result = await client.post(
      url=dpsGroupReq,
      headers=header,
      json={'query': ''},
      timeout=None
    )
    result = result.json()

  finalResult: list[str] = []

  for group in result:
    finalResult.append(group['enrollmentGroupId'])

  return finalResult

print(f"Initializing {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

#### CON TEST ####
# List devices from all hubs:
async def list_hub_devices():
  tasks = []
  for hub in hubs:
    task = asyncio.create_task(getHubData(hub['hubname'], hub['key'], hub['policy_name'], True))
    tasks.append(task)
  await asyncio.gather(*tasks)

# List devices from all hubs:
async def list_dps_registrations():
  tasks = []
  for dps in dpS:
    task = asyncio.create_task(getDPSData(dps['dpsname'], dps['key'], dps['policy_name'], True))
    tasks.append(task)
  await asyncio.gather(*tasks)

asyncio.run(list_hub_devices())
asyncio.run(list_dps_registrations())

#### IOTHUB ####
allDevices = []

# List devices from all hubs:
async def list_all_hub_devices():
  tasks = []
  for hub in hubs:
    task = asyncio.create_task(getHubData(hub['hubname'], hub['key'], hub['policy_name']))
    tasks.append(task)
  hubDevices = await asyncio.gather(*tasks)
  allDevices = [device for devices in hubDevices for device in devices]
  return allDevices

allDevices = asyncio.run(list_all_hub_devices())
print(f'TOTAL NUMBER OF DEVICES: {len(allDevices)}')
dfHubDevices = pd.DataFrame(allDevices)
allDevices = []

#### DPS ####

allRegistrations = []

# List devices from all hubs:
async def list_all_dps_registrations():
  tasks = []
  for dps in dpS:
    task = asyncio.create_task(getDPSData(dps['dpsname'], dps['key'], dps['policy_name']))
    tasks.append(task)
  dpsRegist = await asyncio.gather(*tasks)
  allRegistrations = [registration for registrations in dpsRegist for registration in registrations]
  return allRegistrations

allRegistrations = asyncio.run(list_all_dps_registrations())
print(f'TOTAL NUMBER OF REGISTRATIONS: {len(allRegistrations)}')
dfRegistrations = pd.DataFrame(allRegistrations)
allRegistrations = []



print(duckdb.query("""
SELECT
  dpsname,
  COUNT(1) registrationsNotInHub
FROM dfRegistrations dR
LEFT JOIN dfHubDevices dD ON 1=1
  AND dR.assignedHub = dD.iothub
  AND dR.deviceId = dD.deviceId
WHERE 1=1
  AND dD.iothub IS NULL
GROUP BY dpsname
"""))

print(duckdb.query("""
SELECT
  dD.iothub,
  COUNT(1) AS devicesWithoutDPSReg
FROM dfRegistrations dR
RIGHT JOIN dfHubDevices dD ON 1=1
  AND dR.assignedHub = dD.iothub
  AND dR.deviceId = dD.deviceId
WHERE dR.registrationId IS NULL
GROUP BY
  dD.iothub
"""))

print(duckdb.query("""
SELECT
  COUNT(1) AS registrationsWithHubs
FROM dfRegistrations dR
JOIN dfHubDevices dD ON 1=1
  AND dR.assignedHub = dD.iothub
  AND dR.deviceId = dD.deviceId
"""))

print(duckdb.query("""
SELECT COUNT(1) duplicatedDevicesByGroup FROM(
SELECT
  dpsname,
  dR.deviceId,
  COUNT(1) sameRegistrationForMultipleHubs
FROM dfRegistrations dR
JOIN dfHubDevices dD ON 1=1
  AND dR.assignedHub = dD.iothub
  AND dR.deviceId = dD.deviceId
GROUP BY dpsname, dR.deviceId
HAVING COUNT(1) > 1)
"""))

print(duckdb.query("""
SELECT COUNT(1) duplicatedDevicesByDPS, sum(sameRegistrationForMultipleHubs) totalDuplicatedRegistrations FROM(
SELECT
  dR.deviceId,
  dR.assignedHub,
  COUNT(1) sameRegistrationForMultipleHubs
FROM dfRegistrations dR
JOIN dfHubDevices dD ON 1=1
  AND dR.assignedHub = dD.iothub
  AND dR.deviceId = dD.deviceId
GROUP BY dR.deviceId, dR.assignedHub
HAVING COUNT(1) > 1)
"""))


print("Exporting to CSV...")
queryDuplicateRegistrations = """
WITH 
  deviceCount as (SELECT
      dR.deviceId,
      dR.assignedHub,
      COUNT(1) sameRegistrationForMultipleHubs
    FROM dfRegistrations dR
    JOIN dfHubDevices dD ON 1=1
      AND dR.assignedHub = dD.iothub
      AND dR.deviceId = dD.deviceId
    GROUP BY dR.deviceId,dR.assignedHub
    HAVING COUNT(1) > 1)
SELECT 
  dC.deviceId,
  dC.sameRegistrationForMultipleHubs, 
  dR.dpsname,
  dR.group, 
  dC.assignedHub,
  dR.lastUpdatedDateTimeUtc
FROM deviceCount dC
JOIN dfRegistrations dR ON 1=1
  AND dC.deviceId = dR.deviceId
  AND dR.assignedHub = dC.assignedHub
"""

queryDevicesWithoutDPS = """
SELECT
  dD.*
FROM dfRegistrations dR
RIGHT JOIN dfHubDevices dD ON 1=1
  AND dR.assignedHub = dD.iothub
  AND dR.deviceId = dD.deviceId
WHERE dR.registrationId IS NULL
"""

queryRegistrationsWithoutHubs = """
SELECT
  dR.*
FROM dfRegistrations dR
LEFT JOIN dfHubDevices dD ON 1=1
  AND dR.assignedHub = dD.iothub
  AND dR.deviceId = dD.deviceId
WHERE 1=1
  AND dD.iothub IS NULL
"""



# Using Arrow to compress the results
tbl = duckdb.query(queryDevicesWithoutDPS).arrow()
df = tbl.to_pandas().to_csv('devicesWithoutDPS.csv')

tbl = duckdb.query(queryRegistrationsWithoutHubs).arrow()
df = tbl.to_pandas().to_csv('regWithoutHubs.csv')

tbl = duckdb.query(queryDuplicateRegistrations).arrow()
df = tbl.to_pandas().to_csv('duplicateRegistrations.csv')

print(f"Finishing {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

# Deleting duplicate registrations
if data['deleteDPSRegistrations']:
  print("Deleting duplicate registrations...")

  queryDuplicateRegistrations = """
    SELECT
          dR.deviceId,
          dR.assignedHub,
          COUNT(1) sameRegistrationForMultipleHubs
        FROM dfRegistrations dR
        JOIN dfHubDevices dD ON 1=1
          AND dR.assignedHub = dD.iothub
          AND dR.deviceId = dD.deviceId
        GROUP BY dR.deviceId,dR.assignedHub
        HAVING COUNT(1) > 1
    """

  async def deleteRegistrations():
    tbl = duckdb.query(queryDuplicateRegistrations).arrow()
    df = tbl.to_pandas()
    tasks = []
    for index, row in df.iterrows():
      for dps in dpS:
        task = asyncio.create_task(deleteRegistration(dps['dpsname'], dps['key'], dps['policy_name'], row['deviceId']))
        tasks.append(task)

    await asyncio.gather(*tasks)

  asyncio.run(deleteRegistrations())
else:
  print("Duplicate registrations will not be deleted")

